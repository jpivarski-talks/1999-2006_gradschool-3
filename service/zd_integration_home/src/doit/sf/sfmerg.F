*
* $Id: sfmerg.F,v 1.12 2003/03/05 18:35:34 dpp Exp $
*
* $Log: sfmerg.F,v $
* Revision 1.12  2003/03/05 18:35:34  dpp
*      -> re-organize calculation to avoid MULST*NWIR**2, which can overflow
*         ... but restored to original for "no affect on compress" version
*
* Revision 1.11  2002/09/05 18:49:31  dpp
*      -> remove local ICHAIN
*      -> put diagnostic stops in common
*      -> add entry to initialize diagnostic stops
*
* Revision 1.10  2002/05/23 14:20:38  dpp
*      -> NORM_ALT decalred integer, not logical
*      -> SAVMERGE remains a logical but is now used as a logical
*
* Revision 1.9  2000/08/18 19:10:47  dpp
*      -> revise diagnostic breakpoints
*
* Revision 1.8  2000/01/06 22:23:47  dpp
* weight the Z contributions from the two chains
* by the weight assigned in SFCHAN
*
* Revision 1.7  1999/12/09 21:27:04  dpp
* diagnostics
*
* Revision 1.6  1999/07/08 21:31:27  lyon
* Fix divide by zero error (SFZML)
*
* Revision 1.5  1999/05/17 14:56:43  dpp
* diagnostic switch of diagnostic print statements
*
* Revision 1.4  1999/04/29 13:31:33  dpp
* syntax error
*
* Revision 1.3  1999/04/27 19:35:04  dpp
* sum miss distances from both directions
*
* Revision 1.2  1999/01/29 14:49:54  dpp
* extend to stereo layers; F77
*
* Revision 1.1.1.1  1998/02/06 19:11:46  dpp
* DOIT first release.
*
* Revision 1.1.1.1  1997/04/30 12:31:41  clib
* Developmental version of DUET.
*
* Revision 1.3  1997/02/25 21:54:39  dpp
* do not merge chains from different clone groups
*
* Revision 1.2  1996/02/14 21:04:26  zfiles
* remove call to SFLWF; use SFLSFA etc
*
* Revision 1.1.1.1  1994/10/08 01:00:43  zfiles
* first version of doit in CVS
*
*
#include "sys/CLEO_machine.h"
#include "pilot.h"
*CMZ :  6.00/14 01/03/94  16.47.52  by  Rob Kutschke
*CMZ :  6.00/07 31/08/93  13.55.49  by  Rob Kutschke
*CMZ :  6.00/01 23/04/93  15.16.54  by  Dan Peterson
*-- Author :
      SUBROUTINE SFMERG
C......................................................................
C.
C. SFMERG - Merge the basic chains into longer chains
C.
C. COMMON    : /STEPCn/
C. CALLS     :
C. CALLED    : SFIND
C. AUTHOR    : D. Peterson
C. VERSION   : 1.00
C. CREATED   : 20-Jul-88
C. LAST MOD  : 06-Oct-88
C.
C. Modification Log.
C. 26-July-89 changed to work in SSF layers
C. 05-MAY-89  NWIRTF -> NWRSSF (in SFCOM) to be independent of TFGEOM
C. 06-Oct-88 added dummy array ISTFBD to allow array bound checking
C. 26-Sept-88 add cut on maximum gap to span in merge
C. 23-Sept-88 more rework in "L2F between L1L and L1LNXT", for overflow
C. 13-Sept-88  reworked WNPX in "L2F between L1L and L1LNXT"
C.                to avoid overflow problem
C......................................................................
#if defined(CLEO_TYPCHK)
      IMPLICIT NONE
#endif
      SAVE
#include "doit/sfseq/sfpar.inc"
#include "doit/sfseq/sfcom.inc"

#if defined(CLEO_XTSUBS)
#include "doit/sfseq/xts_cntl.inc"
#endif

C...... LOCAL VARIABLE DOCUMENTAION
C I12......(2) OUTER AND INNER LOOP COUNTERS
C ADFL.....(2,2) ADDRESS OF FIRST/LAST HIT IN OUTER/INNER LOOP
C LFL......(2,2) LAYER OF FIRST/LAST HIT IN OUTER/INNER LOOP
C WFL......(2,2) WIRE OF FIRST/LAST HIT IN OUTER/INNER LOOP
C USE_Z....(2) USE Z INFO IN OUTER/INNER LOOP CHAIN
C BACKUPOK.BACKING UP THE MAJOR CHAIN OK 
C LMXDIFOK.LOOSE MAXIMUM DIFFERENCE CUT OK
C MAXDIFOK.MAXIMUM DIFFERENCE CUT OK
C BIGDIFOK.NUMBER OF COMPARES WITH BIG DIFERENCE OK
C WHATEVER.OK TO COMTINUE CHECKING IF THIS MERGE CAN BE TESTED
C VELDIF...VELOCITY DIFFERENCE
C IDIFS....RUNNING SUM OF DIFFERNCES (ABS)
C NDIF.....NUMBER OF ELEMENTS IN IDIFS
C IADV2F...NUMBER OF TIMES THAT LAYER IS ADVANCED IN MINOR CHAIN
C IEXT1L...NUMBER OF TIMES THAT THE LAST MAJOR CHAIN HIT IS EXTENDED
C NCCPSF...NUMBER OF TIMES THAT CELL CUT PARALLEL FAILS
C LCCP.....FLAG TO TEST THE CELL CUT PARALLEL THING
C LFIRST...FLAG TO SPECIFY THE FIRST HIT PROECESSED FROM THE MINR CHAIN
C NORM_ALT.=1 IF NORMAL (MAJR->MINR) DIRECTION, =2 IF ALTERNATE
C SAVMERGE.=.TRUE. IF THE MERGE IS SAVED
C L1.......INDEX OF I12 THAT GIVES THE LOW RADIUS CHAIN
C L2.......INDEX OF I12 THAT GIVES THE HIGH RADIUS CHAIN
C MAJR.....INDEX OF I12 THAT GIVES THE MAJOR (LONGER) CHAIN
C MINR.....INDEX OF I12 THAT GIVES THE MINOR CHAIN
C MAJR_TMP.TEMPORAY VALUE OF MAJR TO ALLOW TESTING IN BOTH DIRECTIONS
C MINR_TMP.TEMPORAY VALUE OF MINR TO ALLOW TESTING IN BOTH DIRECTIONS
C END1.....THE END(1 OR 2) OF THE MINOR CHAIN THAT POINTS TO MAJOR
C END2.....THE END (1 OR 2) OF THE MAJOR CHAIN THAT POINTS TO MINOR
C LEN1.....LENGTH OF THE MAJOR CHAIN
C LEN2.....LENGTH OF THE MINOR CHAIN
C CFOR.....ADDRESS CORRECTION TO ISTFOR TO GO INTO MINOR
C CBAK.....ADDRESS CORRECTION TO ISTFOR TO GO AWAY FROM MINOR
C DIRE.....MULTIPLIER SO THAT .GE. CAN BE USED IN BOTH DIRECTIONS
C AD1L.....ADDRESS OF HIT ON MAJOR CLOSE TO MINOR
C L1L......LAYER OF AD1L
C WIL......WIRE OF AD1L
C AD2F.....ADDRESS OF HIT ON MINOR CLOSE TO MAJOR
C L2F......LAYER OF AD2F
C W2F......WIRE OF AD2F
C AD1LNXT..ADRESS OF NEXT HIT AFTER AD1L
C L1LNXT...LAYER OF AD1LNXT
C W1LNXT...WIRE  OF AD1LNXT
C ZL1L.....Z VALUE OF LAYER L1L
C ZL2F.....Z VALUE OF LAYER W1L
C WZL1L....WIEGHT OF ZL1L
C WZL2F....WIEGHT OF ZL2F
C UZ1L.....=1 INDICATES USE OF Z VALUE OF LAYER L1L 
C UZ2F.....=1 INDICATES USE OF Z VALUE OF LAYER L2F
C CMPRZ....=1 INDICATES THAT TWO Z VALUES SHOULD BE CLOSE
C ZNDIF....DIFF IN NUMBER OF MEASUREMENTS IN Z VALUES FOR LAYERS L1L AND L2F  
C ZNSUM....SUM OF NUMBER OF MEASUREMENTS IN Z VALUES FOR LAYERS L1L AND L2F
C ZDIF.....DIFFERENCE OF Z VALUES
C BTYPE....IDENTIFIES RELATIVE LOCATION OF L2F TO THE INTERVAL {L1L : L1LNXT}
C USELAYER.=1 IF MINOR CHAIN HIT IN THIS LAYER IS TO BE USED
C WLF0.....WIRE NUMBER  -LAST-FOUND    -MULTIPLIED AND RELATIVE TO 0
C WNRX.....WIRE NUMBER  -NOW -RADIALOUT-MULTIPLIED
C WNRXZ....WIRE NUMBER  -NOW -RADIALOUT-MULTIPLIED if in layer with same TANSSF
C WNPX.....WIRE NUMBER  -NOW -PREDICTED-MULTIPLIED
C DIFTN....DIFFERENCE IN TANSSF
C DIFTNA...ABS OF DIFTN
C ZNOWX....Z VALUE IN CURRENT LAYER;IN meters MULTIPLIED
C WZNOWX...TOTAL WEIGHT SUMMED IN CALCULATING ZNOWX
C LVLU.....VELOCITY, USED
C W1LF0....WIRE NUMBER 1-LAST-FOUND    -MULTIPLIED AND RELATIVE TO 0
C W1NRXZ...WIRE NUMBER 1-NOW -RADIALOUT-MULTIPLIED if in layer with same TANSSF
C W1NRX....WIRE NUMBER 1-NOW -RADIALOUT-MULTIPLIED
C W2LF0....WIRE NUMBER 2-LAST-FOUND    -MULTIPLIED AND RELATIVE TO 0
C W2NRXZ...WIRE NUMBER 2-NOW -RADIALOUT-MULTIPLIED if in layer with same TANSSF
C W2NRX....WIRE NUMBER 2-NOW -RADIALOUT-MULTIPLIED
C WNPU.....WIRE NUMBER  -NOW -PREDICTED-USER
C WSHFZ....SHIFT FROM Z
C NWIRTX...NUMBER OF WIRES IN LAYER, MULTIPLIED
C IDIF.....DIFFERENCE IN WIRE NUMBER
C IDIFA....ABS OF IDIF
C IDRAD....RADIUS DIFFERENCE
C WASMRG...(I,J) (J) WAS LOW/HIGH RADIUS (I) ELEMENT IN NEW CHAIN
C CLOWR....LOW RADIUS CHAIN (L1 IS INDEX TO I12SAV) FOR COMMON MERG CODE
C CHIGHR...HIGH RADIUS CHAIN (L2 IS INDEX TO I12SAV) FOR COMMON MERG CODE
C CMAJOR...MAJOR CHAIN (1 IS INDEX TO I12SAV) FOR COMMON MERG CODE
C CMINOR...MINOR CHAIN (2 IS INDEX TO I12SAV) FOR COMMON MERG CODE
C DELT.....TEMP VALUE OF DELMHT(IMERG) FOR COMMON MERG CODE
C DELTS....DELT (SINGLE HIT)
C END2ST...TEMP VALUE OF END2S(IMERG) FOR COMMON MERG CODE
C WLOOP....LOOP NUMBER THROUGH THE MERGING PROCESS
C ZLOOP....LOOP NUMBER FOR FILLING Z INFORMATION
C ISUPCE...INDEX FOR SUPER CHAIN ELEMENT NUMBER
C SWAPMERG.=1 IF THE MERGES ARE TO BE SWAPPED IN ORDER
C LAST.....MERGE INDEX, POINTS TO NOW
C NOW......MERGE INDEX,    HAS PRESENT "BEST PARAMETERS"
C LFROM....MERGE INDEX, POINTS TO NEXT
C NEXT.....MERGE INDEX,    BEING TESTED AGAINST NOW
C ISFZM....Z MEASUREMENT INDEX
C ZNCHNT...TEMP VALUE OF ZNCHN FOR COMPRESSING THE LIST
C ZNDEL....NUMBER OF Z MEASUREMENTS OUT OF ZNDHN DELETED
C SUBTR1...AMOUNT TO SUBTRACT
C SUBTR2...AMOUNT TO SUBTRACT
C IMERG....MERGE INDEX
C OKMERG...OK TO MERGE
C IDUM.....DUMMY IN INDEX TO COUNT MERGES
C I3.......NEXT CHAIN NUMBER
C I4.......TOTAL NUMBER OF SUBCHAINS CONTRIBUTING TO MERGE
C NXTSAV...TEMP STORAGE FOR CHNGING ORDER OF CHAINS
C I........OUTER INDEX FOR ORDERING MERGES
C J........INNER INDEX FOR ORDERING MERGES
C JMIN.....STARTING POINT FOR J
C K........INDEX FOR DELETEING OVERLAPPING LAYERS IN MERGE
C IN.......ARRAY TO PASS TO CHVIEW
C IIN......INDEX TO FILL ARRAY IN
C IGO......ACCEPTED VARIABLE TO CONTINUE
C KILLOV...kill overide
C FIRSTTST.FIRST TEST
C SELECTC..CHAIN NUMBER TO SELECT FOR DISPLAY
C ISEL.....LOOP INDEX
C PASS_LEVEL..LEVEL OF PASS FOR WAITING FOR ACCEPTANCE
      INTEGER I12(2),ADFL(2,2),LFL(2,2),WFL(2,2),USE_Z(2)
      INTEGER BACKUPOK,LMXDIFOK,MAXDIFOK,BIGDIFOK,WHATEVER
      INTEGER VELDIF,IDIFS,NDIF,IADV2F,IEXT1L
      INTEGER NCCPSF
      INTEGER NORM_ALT
      LOGICAL LCCP,LFIRST,SAVMERGE
      INTEGER L1,L2,MAJR,MINR,END1,END2,LEN1,LEN2,CFOR,CBAK,DIRE
      INTEGER MAJR_TMP,MINR_TMP
      INTEGER AD1L,L1L,W1L,AD2F,L2F,W2F
      INTEGER AD1LNXT,L1LNXT,W1LNXT
      INTEGER ZL1L,ZL2F,WZL1L,WZL2F
      INTEGER UZ1L,UZ2F,CMPRZ
      INTEGER ZNDIF,ZNSUM,ZDIF
      INTEGER BTYPE,USELAYER
      INTEGER WLF0,WNRX,WNPX,LVLU
      INTEGER W1LF0,W1NRX,W2LF0,W2NRX,WNPU
      INTEGER NWIRTX,IDIF,IDIFA,IDRAD
      INTEGER WNRXZ,W1NRXZ,W2NRXZ,WSHFZ,DIFTN,DIFTNA,ZNOWX,WZNOWX
      integer WNRXZ_old,W1NRXZ_old,W2NRXZ_old
      INTEGER WASMRG(2,MCHAIN)
      INTEGER CMAJOR,CMINOR,CLOWR,CHIGHR,DELT,DELTS,END2ST
      INTEGER WLOOP,ZLOOP,ISUPCE
      INTEGER SWAPMERG,LAST,NOW,LFROM,NEXT
      INTEGER IMERG,OKMERG,IDUM,I3,I4,NXTSAV
      INTEGER ISFZM,ZNCHNT,ZNDEL,SUBTR1,SUBTR2
      INTEGER I,J,JMIN,K
      INTEGER IN(MCHANM),IIN,IGO
      INTEGER FIRSTTST,KILLOV
      INTEGER PASS_LEVEL,ABORT
      INTEGER SELECTC(2),ISEL
      INTEGER ITEMP,ITEMP2,ITEMP3

C----------------------Executable code starts here---------------------

#if defined(CLEO_SFDIAG)
      PRINT 9991,ZDRCHN
 9991 FORMAT(' SFMERGs:ZDRCHN:',10I6)
#endif

C IF SUPER CHAINS ARE BEING USED INSTEAD OF MERGED CHAINS,
C LOAD THE SUPER CHAIN LIST WITH THE SIMPLE CHAINS
      IF(CNTLMG.EQ.2)THEN
         NSUPCH=0
         NSUPCE=0
         DO 1 ICHAIN=1,NCHAIN
            IF(NSUPCH+1.GT.MSUPCH)GO TO 2
            IF(NSUPCE+1.GT.MSUPCE)GO TO 2
            NSUPCH=NSUPCH+1
            SUPCAD(NSUPCH)=NSUPCE+1
            SUPCLN(NSUPCH)=1
            SUPCUS(NSUPCH)=1
            NSUPCE=NSUPCE+1
            SUPCEL(NSUPCE)=ICHAIN
 1       CONTINUE
 2       CONTINUE
      ENDIF

C INITIALIZE
      IF(NCHAIN.LE.1)GO TO 399
      CALL VZERO(WASMRG,2*NCHAIN)
      NMERG=0
      NXTMRG(0)=1
#if defined(CLEO_SFDIAG)
      FIRSTTST=1
#endif

C START OUTER LOOP
      I12(1)=ICHAN1
      GO TO 5
 3    I12(1)=NXTCHN(I12(1))
 5    IF(I12(1).EQ.0)GO TO 93
      IF(NXTCHN(I12(1)).EQ.0)GO TO 93
      IF(ICHANU(I12(1)).LE.4)GO TO 91

C ADDRESSES,LAYERS AND WIRES
      ADFL(1,1)=LINCHN(I12(1))
      LFL(1,1)=LAYSSF(SFLSFA(ADFL(1,1)))
      WFL(1,1)=WIRSSF(ADFL(1,1))
      ADFL(2,1)=MINCHN(I12(1))
      LFL(2,1)=LAYSSF(SFLSFA(ADFL(2,1)))
      WFL(2,1)=WIRSSF(ADFL(2,1))

C START INNER LOOP
      I12(2)=NXTCHN(I12(1))
      GO TO 9
 7    I12(2)=NXTCHN(I12(2))
 9    IF(I12(2).EQ.0)GO TO 89
      IF(NMERG.GE.MMERG)GO TO 93
      IF(ICHANU(I12(2)).LE.4)GO TO 81

#if defined(CLEO_SFDIAG)
      IN(1)=I12(1)
      IN(2)=I12(2)
      IN(3)=0
      CALL DSF_CHVIEW(IN)
      PRINT 1011,I12(1),I12(2)
 1011 FORMAT(' SFMERG: testing chains ',I3,' and',I3)
      PASS_LEVEL=0
#endif

C REQUIRE TWO CHAINS ARE COMPATIBLE FOR MATCHING
      IF(CLNCHN(I12(1)).NE.CLNCHN(I12(2)))THEN
#if defined(CLEO_SFDIAG)
         PRINT 1012
 1012    FORMAT(' SFMERG: FAIL: compatibility')
#endif
         GO TO 81
#if defined(CLEO_SFDIAG)
      ELSE
         PASS_LEVEL=1
         PRINT 1013
 1013    FORMAT(' SFMERG: pass compatibility')
#endif
      ENDIF

C ADDRESSES,LAYERS AND WIRES
      ADFL(1,2)=LINCHN(I12(2))
      LFL(1,2)=LAYSSF(SFLSFA(ADFL(1,2)))
      WFL(1,2)=WIRSSF(ADFL(1,2))
      ADFL(2,2)=MINCHN(I12(2))

C layssf etc  gives the ssf layer number from the sf layer number

      LFL(2,2)=LAYSSF(SFLSFA(ADFL(2,2)))
      WFL(2,2)=WIRSSF(ADFL(2,2))

C USE L1 AND L2 AS THE  INDEX TO ORDER CHAINS BY THE LAST HIT;
C I12(L1) GIVES THE CHAIN WITH THE LAST HIT AT LOWER RADIUS.
C DO NOT MERGE WHEN THE LAST HIT IF THE TWO CHAINS IS IN THE SAME LAYER. 
c23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
      IF(LFL(2,1).EQ.LFL(2,2))THEN
#if defined(CLEO_SFDIAG)
         PRINT 1014,LFL(2,1)
 1014    FORMAT(' SFMERG: FAIL: chains have same last layer=',I3)
#endif
         GO TO 81
#if defined(CLEO_SFDIAG)
      ELSE
         PASS_LEVEL=2
         PRINT 1015
 1015    FORMAT(' SFMERG: pass: chains have different last layer')
#endif
      ENDIF

      L1=1
      IF(LFL(2,1).GT.LFL(2,2))L1=2
      L2=3-L1

C REQUIRE FIRST HIT OF I12(L1) BE BEFORE FIRST HIT OF I12(L2)
      IF(LFL(1,L1).GE.LFL(1,L2))THEN
#if defined(CLEO_SFDIAG)
         PRINT 1016,LFL(1,L1),LFL(1,L2)
 1016    FORMAT(' SFMERG: FAIL: require 1st hit inner chain to inside;',
     2          I3,'>/=',I3)
#endif
         GO TO 81
#if defined(CLEO_SFDIAG)
      ELSE
         PASS_LEVEL=3
         PRINT 1017
 1017    FORMAT(' SFMERG: pass: require 1st hit inner chain to inside')
#endif
      ENDIF
c23456789 123456789 123456789 123456789 123456789 123456789 123456789 12

C CHECK THAT THE VELOCITIES MATCH
      VELDIF=IABS(LVLCHN(2,I12(L1))-LVLCHN(1,I12(L2)))
c standard, historically .4*1024=409
c to 4/16            IF(VELDIF.GT.614)THEN
c after 4/16/99      IF(VELDIF.GT.300)THEN
      IF(VELDIF.GT.MVCTSF)THEN
#if defined(CLEO_SFDIAG)
         ITEMP=MVCTSF
         PRINT 1018,VELDIF,LVLCHN(2,I12(L1)),LVLCHN(1,I12(L2)),ITEMP
 1018    FORMAT(' SFMERG: FAIL: velocity difference=',I6,
     2   ' (lowrad=',I5,' hirad=',I5,') > ',I6)
#endif
         GO TO 81
#if defined(CLEO_SFDIAG)
      ELSE
         PASS_LEVEL=4
         ITEMP=MVCTSF
         PRINT 1019,VELDIF,LVLCHN(2,I12(L1)),LVLCHN(1,I12(L2)),ITEMP
 1019    FORMAT(' SFMERG: pass: velocity difference=',I6,
     2   ' (lowrad=',I5,' hirad=',I5,') </= ',I6)
#endif
      ENDIF

C CHECK THAT THE GAP: BETWEEN THE LAST HIT IF THE LOW RADIUS CHAIN 
C  AND THE FIRST HIT IF THE HIGH RADIUS CHAIN, IS NOT TO BIG 
      IF((LFL(1,L2)-LFL(2,L1)) .GT. MGCTSF)THEN
#if defined(CLEO_SFDIAG)
         ITEMP=MGCTSF
         PRINT 1020,LFL(1,L2),LFL(2,L1),ITEMP
 1020    FORMAT(' SFMERG: FAIL: radius gap (',I3,',',I3,')'
     2          '  in layers </= ',I6)
#endif
         GO TO 81
#if defined(CLEO_SFDIAG)
      ELSE
         PASS_LEVEL=5
         ITEMP=MVCTSF
         PRINT 1021,MGCTSF
 1021    FORMAT(' SFMERG: pass: radius gap in layers </= ',I6)
#endif
      ENDIF


C DETERMINE Z VALUE TO USE IN SERCHING LAYER
C USE NUMBER OF Z MEASUREMENTS IN EACH CHAIN, EXAMPLE FOR CLEO DR3

C                    CHAIN 1
C         0     1     2     3     4     5     6     7     8      
C        ____________________________________________________
C       |    |                                               |
C  C  0 |none|       use chain 1                             |
C  H    |____|_______________________________________________|
C  A  1 |    |           |                             |
C  I    |    | use both  |_____      use chain 1  _____|
C  N  2 |    |           :     |                 |
C       |use |_____ _ _ _:     |_____       _____|
C  2  3 |chain     |   use both      |     |
C       | 2  |     |_____require     |_____|
C     4 |    |           |   match   |
C       |    |           |___________|
C     5 |    |                 |                 
C       |    |use chain 2 _____|            out of bounds
C     6 |    |           |
C       |    |      _____|        ZNMIN1=1
C     7 |    |     |              ZNMIN2=2
C       |    |_____|              ZNMIN3=5
C     8 |    |                                            
C       |____|
       
      USE_Z(1)=1
      IF(ZNCHN(I12(1)).LT.ZNMIN1)USE_Z(1)=0
      USE_Z(2)=1
      IF(ZNCHN(I12(2)).LT.ZNMIN1)USE_Z(2)=0
      CMPRZ=0
      IF((USE_Z(1).EQ.1).AND.(USE_Z(2).EQ.1))THEN
         ZNDIF=ZNCHN(I12(1))-ZNCHN(I12(2))
         IF(ZNDIF.LE.-ZNMIN2)USE_Z(1)=0
         IF(ZNDIF.GE. ZNMIN2)USE_Z(2)=0
      ENDIF
      IF((USE_Z(1).EQ.1).AND.(USE_Z(2).EQ.1))THEN
         ZNSUM=ZNCHN(I12(1))+ZNCHN(I12(2))
         IF(ZNSUM.GE. ZNMIN3)CMPRZ=1
      ENDIF




C USE  MINR AND MAJR AS THE INDEX TO ORDER CHAINS AS SHORT AND LONG
C IF MAJR POINTS RADIALLY OUTWARD TO MINR, END2=2, END1=1, CFOR=0, DIRE=+1
C IF MAJR POINTS RADIALLY  INWARD TO MINR, END2=1, END1=2, CBAK=0, DIRE=-1
C USE SPANNED DISTANCE RATHER THAN {NUMBER OF HITS} TO DETERMINE LENGTH
C              DO NOT USE {LENCHN(I12(MAJR)).LT.LENCHN(I12(MINR))}

      MAJR=L1
      MINR=L2
      LEN1=RADSSF(LFL(2,MAJR))-RADSSF(LFL(1,MAJR))
      LEN2=RADSSF(LFL(2,MINR))-RADSSF(LFL(1,MINR))
      IF(LEN1.LT.LEN2)THEN
         MAJR=L2
         MINR=L1
      ENDIF

C SET UP FOR THE NORMAL DIRECTION

      NORM_ALT=1
      SAVMERGE=.FALSE.

 21   CONTINUE
      IF(NORM_ALT.EQ.1)THEN
         MAJR_TMP=MAJR
         MINR_TMP=MINR
      ELSE
         MAJR_TMP=MINR
         MINR_TMP=MAJR
      ENDIF

C MORE SET UP FOR COMPARING HITS

      IF(MAJR_TMP.EQ.L1)THEN
         END2=2
      ELSE
         END2=1
      ENDIF
      END1=3-END2

      CFOR=(2-END2)*MHITSF
      CBAK=(END2-1)*MHITSF
      DIRE=-3+2*END2

C ADDRESSES,LAYERS AND WIRES
      AD1L=ADFL(END2,MAJR_TMP)
      L1L=LFL(END2,MAJR_TMP)
      W1L=WFL(END2,MAJR_TMP)
      ZL1L=ZR0CHN(I12(MAJR_TMP))
     2    +ZDRCHN(I12(MAJR_TMP))*RADSSF(L1L)/100/MULST
      AD2F=ADFL(END1,MINR_TMP)
      L2F=LFL(END1,MINR_TMP)
      W2F=WFL(END1,MINR_TMP)
      ZL2F=ZR0CHN(I12(MINR_TMP))
     2    +ZDRCHN(I12(MINR_TMP))*RADSSF(L2F)/100/MULST
      WZL2F=SFZMS1(I12(MINR_TMP))

C SET USE OF Z VALUE FOR MAJOR AND MINOR CHAINS

      UZ1L=USE_Z(MAJR_TMP)
      UZ2F=USE_Z(MINR_TMP)

#if defined(CLEO_SFDIAG)
      PRINT 1023,I12(MAJR_TMP),UZ1L,I12(MINR_TMP),UZ2F,CMPRZ
 1023 FORMAT(' SFMERG: major=',I3,'..useZ ',I1,
     2       ' ;  minor=',I3,'..useZ ',I1,' compare=',I1)
#endif

C LOOP OVER THE HITS IN THE MINR_TMP CHAIN, COMPARING THEM TO THE 
C HITS IN THE MAJR_TMP CHAIN THAT ARE EITHER IN THE SAME LAYER OR
C IN LAYERS THAT BRACKET THE MINR_TMP CHAIN LAYER
C INTITIAL VALUES (AD2F,L2F,W2F,ZL2F)  WERE SET ABOVE 

      BACKUPOK=1
      LMXDIFOK=1
      MAXDIFOK=1
      BIGDIFOK=1
      IDIFS=0
      NDIF=0
      IADV2F=0
      IEXT1L=0
      NCCPSF=0
      LCCP=.TRUE.
      LFIRST=.TRUE.

C ADVANCE THE LOOP OVER THE HITS IN THE MINR_TMP CHAIN
 31   IF(.NOT.LFIRST)THEN
         IF(AD2F.EQ.ADFL(END2,MINR_TMP))THEN

#if defined(CLEO_SFDIAG)
            PRINT 1022
 1022       FORMAT(' SFMERG: end: at high of minor chain')
#endif

            GO TO 71
         ENDIF

         IADV2F=IADV2F+1
         AD2F=ISTFBD(CFOR+AD2F)
         L2F=LAYSSF(SFLSFA(AD2F))
         W2F=WIRSSF(AD2F)
         ZL2F=ZR0CHN(I12(MINR_TMP))
     2       +ZDRCHN(I12(MINR_TMP))*RADSSF(L2F)/100/MULST
         WZL2F=SFZMS1(I12(MINR_TMP))
      ENDIF
      LFIRST=.FALSE.

C CHOOSE L1L AND L1LNXT TO BRACKET L1F OR EXTRAPOLATE TO IT 

C BACK UP THE LAST HIT IN THE MAJR_TMP CHAIN TO THE POINT WHERE THE LAYER
C    IS (THE SAME OR PRECEDES) THE LAYER FOR FIRST HIT IN THE MINR_TMP CHAIN
C TEST IF THE HITS ARE IN THE SAME LAYER
C TEST IF THE MINR_TMP CHAIN HIT IS BEYOND THE LAST HIT IN THE MAJR_TMP CHAIN
C TEST IF THE MINR_TMP CHAIN HIT IS BRACKETED BY TWO MAJR_TMP CHAIN HITS
C THEN ADVANCE THE LAST HIT OF THE MAJOR CHAIN
      BTYPE=0
 41   CONTINUE
      IF    (DIRE*L2F.LT.DIRE*L1L)THEN
         IF(AD1L.EQ.ADFL(END1,MAJR_TMP))THEN
            BACKUPOK=0
            GO TO 71
         ENDIF
         AD1LNXT=AD1L
         L1LNXT=L1L
         W1LNXT=W1L
         AD1L=ISTFBD(CBAK+AD1L)
         L1L=LAYSSF(SFLSFA(AD1L))
         W1L=WIRSSF(AD1L)
      ELSEIF(L2F.EQ.L1L)THEN
         BTYPE=1
      ELSEIF(DIRE*L2F.GT.DIRE*L1L)THEN
         IF(AD1L.EQ.ADFL(END2,MAJR_TMP))THEN
            BTYPE=3
         ELSE
            IF(DIRE*L2F.LT.DIRE*L1LNXT)THEN
               BTYPE=2
            ELSE
               AD1L=ISTFBD(CFOR+AD1L)
               L1L=LAYSSF(SFLSFA(AD1L))
               W1L=WIRSSF(AD1L)
               IF(AD1L.NE.ADFL(END2,MAJR_TMP))THEN
                  AD1LNXT=ISTFBD(CFOR+AD1L)
                  L1LNXT=LAYSSF(SFLSFA(AD1LNXT))
                  W1LNXT=WIRSSF(AD1LNXT)
               ENDIF
            ENDIF
         ENDIF
      ENDIF
      IF(BTYPE.EQ.0)GO TO 41
      USELAYER=1

C CALCULATE Z FOR THE EXTRAPOLATION

      ZL1L=ZR0CHN(I12(MAJR_TMP))
     2    +ZDRCHN(I12(MAJR_TMP))*RADSSF(L1L)/100/MULST
      WZL1L=SFZMS1(I12(MAJR_TMP))
      ZNOWX=0
      WZNOWX=0
      IF(UZ1L.EQ.1)THEN
         ZNOWX=ZNOWX+ZL1L*WZL1L
         WZNOWX=WZNOWX+WZL1L
      ENDIF
      IF(UZ2F.EQ.1)THEN
         ZNOWX=ZNOWX+ZL2F*WZL2F
         WZNOWX=WZNOWX+WZL2F
      ENDIF
      IF(WZNOWX.GT.0)ZNOWX=ZNOWX/WZNOWX
      IF(CMPRZ.EQ.1)THEN
         ZDIF=ABS(ZL1L-ZL2F)
         IF(ZDIF.GT.ZDMAX)USELAYER=0
      ENDIF

C HERE IF THIS LAYER IS NOT EXCLUDED 
      IF(USELAYER.NE.0)THEN

C HERE IF L2F=L1L
         IF(BTYPE.EQ.1)THEN
            WNPU=W1L
            WNPX=WNPU*MULST
            WSHFZ=0.

c23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C HERE, L2F IS BETWEEN L1L AND L1LNXT
C WITH Z CORRECTION
         ELSEIF(BTYPE.EQ.2)THEN
            W1LF0=W1L*MULST+OFFSSF(L1L)
            W1NRXZ=W1LF0+
     2           W1LF0*(NWRSSF(L2F)-NWRSSF(L1L))/NWRSSF(L1L)
     3           -OFFSSF(L2F)

            w1nrxz_old=W1LF0*NWRSSF(L2F)/NWRSSF(L1L)-OFFSSF(L2F)
            w1nrxz=w1nrxz_old

            DIFTN=TANSSF(L2F)-TANSSF(L1L)
            WSHFZ=ZNOWX*DIFTN/MULST
            W1NRX=W1NRXZ+WSHFZ
         
            NWIRTX=NWRSSF(L2F)*MULST
            IF(W1NRX.LT.0)W1NRX=W1NRX+NWIRTX
            IF(W1NRX.GE.NWIRTX)W1NRX=W1NRX-NWIRTX
            
            W2LF0=W1LNXT*MULST+OFFSSF(L1LNXT)
            W2NRXZ=W2LF0
     2           +W2LF0*(NWRSSF(L2F)-NWRSSF(L1LNXT))/NWRSSF(L1LNXT)
     3           -OFFSSF(L2F)

            w2nrxz_old=W2LF0*NWRSSF(L2F)/NWRSSF(L1LNXT)-OFFSSF(L2F)
            w2nrxz=w2nrxz_old

            DIFTN=TANSSF(L2F)-TANSSF(L1LNXT)
            WSHFZ=ZNOWX*DIFTN/MULST
            W2NRX=W2NRXZ+WSHFZ
            
            IDIF=W2NRX-W1NRX
            IF(IDIF.LT.-NWIRTX/2)W2NRX=W2NRX+NWIRTX
            IF(IDIF.GE. NWIRTX/2)W2NRX=W2NRX-NWIRTX
            
            IDRAD=RADSSF(L1LNXT)-RADSSF(L1L)

C THIS CODE, ALTHOUGH ARITHMETICALLY CORRECT, WAS ABANDONED
C BECAUSE IT WAS SUSEPTABLE TO OVERFLOWS
C OLD      WNPX=( (RADSSF(L2F)-RADSSF(L1L))*W2NRX )/IDRAD
C OLD     1       +( (RADSSF(L1LNXT)-RADSSF(L2F))*W1NRX )/IDRAD
C THIS IS NEW CODE
            IF    (W2NRX.LT.W1NRX)THEN
               WNPX=( (RADSSF(L1LNXT)-RADSSF(L2F))
     1              *(W1NRX-W2NRX) )/IDRAD  +W2NRX
            ELSEIF(W2NRX.GT.W1NRX)THEN
               WNPX=( (RADSSF(L2F)-RADSSF(L1L))
     1              *(W2NRX-W1NRX) )/IDRAD  +W1NRX
            ELSE
               WNPX=W1NRX
            ENDIF
            WNPU=(WNPX+MULSTH)/MULST
C END OF THE SO CALLED NEW CODE HERE


C HERE IF L2F IS BEYOND L1L ; PROJECT OUT FROM LAST HIT OF MAJR_TMP CHAIN
C WITH Z CORRECTION
         ELSEIF(BTYPE.EQ.3)THEN
            WLF0=W1L*MULST+OFFSSF(L1L)
            WNRXZ=WLF0+
     2           WLF0*(NWRSSF(L2F)-NWRSSF(L1L))/NWRSSF(L1L)
     3           -OFFSSF(L2F)

            wnrxz_old=WLF0*NWRSSF(L2F)/NWRSSF(L1L)-OFFSSF(L2F)
            wnrxz=wnrxz_old

            DIFTN=TANSSF(L2F)-TANSSF(L1L)
            WSHFZ=ZNOWX*DIFTN/MULST
            WNRX=WNRXZ+WSHFZ
            
            LVLU=LVLCHN(END2,I12(MAJR_TMP))
            LVLU=LVLU+
     2           ( LVLCHN(END2,I12(MAJR_TMP))
     3            -LVLCHN(END1,I12(MAJR_TMP)))/2
     4           *(RADSSF(L2F)-RADSSF(L1L))
     5           /(RADSSF(L1L)-RADSSF(LFL(END1,MAJR_TMP)))

            WNPX=WNRX+(LVLU*(RADSSF(L2F)-RADSSF(L1L)))/MULST
            IEXT1L=IEXT1L+1
            LCCP=.FALSE.
            WNPU=(WNPX+MULSTH)/MULST
         ENDIF

C CALCULATE THE WIRE NUMBER DIFFERENCE
         NWIRTX=NWRSSF(L2F)*MULST
         IDIF=WNPX-W2F*MULST
         IF(IDIF.GT.( NWIRTX/2))IDIF=IDIF-NWIRTX
         IF(IDIF.LE.(-NWIRTX/2))IDIF=IDIF+NWIRTX


c23456789 123456789 123456789 123456789 123456789 123456789 123456789 12

#if defined(CLEO_SFDIAG)
         PRINT 1025,L2F,W2F,BTYPE,L1L,W1L,L1LNXT,W1LNXT,
     2              ZNOWX,WSHFZ,IDIF
 1025    FORMAT(' SFMERG:test   L',I3,' W',I4,' type ',I1,
     2          ' from L',I3,' W',I4,' Lnxt',I3,' W',I4,
     3          ' Z=',I5,' WSHFZ=',I5,' IDIF=',I6)
#endif



C TEST MERGE CRITERIA (BEFORE INPSPECTING ALL HITS)
         IDIFA=IABS(IDIF)

         IF((IDIFA.GE.12*MULST))THEN
            LMXDIFOK=0
         ENDIF

         IF(IDIFA.GE.MCC1SF)THEN
            MAXDIFOK=0
            GO TO 71
         ENDIF

         IF(LCCP.AND.(IDIFA.GE.MCCPSF))THEN
            NCCPSF=NCCPSF+1
            IF(NCCPSF.GE.MAXPSF)THEN
               BIGDIFOK=0
               GO TO 71
            ENDIF
         ENDIF
         
         IDIFS=IDIFS+IDIFA
         NDIF=NDIF+1

         IF((AD1L.EQ.ADFL(END2,MAJR_TMP)).AND.(IEXT1L.GE.MINEXT))THEN
            IF(NDIF.GE.MLMTSF)THEN

#if defined(CLEO_SFDIAG)
               ITEMP=MINEXT
               ITEMP2=MLMTSF
               PRINT 1035,ITEMP,ITEMP2
 1035          FORMAT(' SFMERG: end, extrapolations>/=',I2,
     2              ' NDIF>/=',I2)
#endif
               GO TO 71
            ENDIF
         ENDIF
      

C PRINT MESSAGE WHEN LAYER IS EXCLUDED (DUE TO Z MISMATCH) 
 
#if defined(CLEO_SFDIAG)
      ELSE
         ITEMP=ZDMAX
         PRINT 1026,L2F,W2F,BTYPE,L1L,W1L,L1LNXT,W1LNXT,
     2              ZNOWX,ZL2F,ZL1L,ZDIF,ITEMP
 1026    FORMAT(' SFMERG:NOTEST L',I3,' W',I4,' type ',I1,
     2          ' from L',I3,' W',I4,' Lnxt',I3,' W',I4,
     3          ' Z=',I5,' mZ=',I6,' MZ=',I6,' dZ=',I6,' lim=',I6)
#endif

C LOOP BACK FOR THE NEXT HIT IN THE MINR_TMP CHAIN
      ENDIF
      GO TO 31

c23456789 123456789 123456789 123456789 123456789 123456789 123456789 12

C TEST MERGE CRITERIA
 71   WHATEVER=1

      IF(WHATEVER.EQ.1)THEN
         IF(BACKUPOK.EQ.0)THEN
            WHATEVER=0   
#if defined(CLEO_SFDIAG)
            PRINT 1024
 1024       FORMAT(' SFMERG: FAIL: at low end of major chain')
         ELSE
            PASS_LEVEL=6
            PRINT 1027
 1027       FORMAT(' SFMERG: continue: not at low end of major chain')
#endif
         ENDIF
      ENDIF

      IF(WHATEVER.EQ.1)THEN
         IF(LMXDIFOK.EQ.1)THEN
            PASS_LEVEL=7
         ENDIF
         IF(MAXDIFOK.EQ.0)THEN
            WHATEVER=0   
#if defined(CLEO_SFDIAG)
            ITEMP=MCC1SF
            PRINT 1031,ITEMP
 1031       FORMAT(' SFMERG: FAIL:   SINGLE    IDIF >/=',I5)
         ELSE
            PASS_LEVEL=8
            ITEMP=MCC1SF
            PRINT 1033,ITEMP
 1033       FORMAT(' SFMERG: continue: SINGLE IDIF OK  <',I5)
#endif
         ENDIF
      ENDIF

      IF(WHATEVER.EQ.1)THEN
         IF(BIGDIFOK.EQ.0)THEN
            WHATEVER=0   
#if defined(CLEO_SFDIAG)
            ITEMP=MCCPSF
            ITEMP2=MAXPSF
            PRINT 1032,NCCPSF,ITEMP,ITEMP2
 1032       FORMAT(' SFMERG: FAIL:',
     2               I4,' hits with IDIF>',I5,', limit=',I5)
         ELSE
            ITEMP=MCCPSF
            ITEMP2=MAXPSF
            PRINT 1036,NCCPSF,ITEMP,ITEMP2
 1036       FORMAT(' SFMERG: continue:',
     2               I4,' hits with IDIF>',I5,', limit=',I5)
#endif
         ENDIF
      ENDIF


      IF(WHATEVER.EQ.1)THEN
         IF(IEXT1L.LT.MINEXT)THEN
#if defined(CLEO_SFDIAG)
            ITEMP=MINEXT
            PRINT 1041,IEXT1L,ITEMP
 1041       FORMAT(' SFMERG: FAIL: ',I2,' extrapolations < minimum=',I2)
#endif

         ELSE
            IDIFS=IDIFS/NDIF
            IF(IABS(IDIFS).GE.MCCASF)THEN
#if defined(CLEO_SFDIAG)
               ITEMP=MCCASF
               PRINT 1042,NDIF,IDIFS,ITEMP
 1042          FORMAT(' SFMERG: FAIL: average of ',I2,' DIFs is ',I5,
     2              '; >/= maximum=',I5)
#endif

            ELSE
#if defined(CLEO_SFDIAG)
               ITEMP=MCCASF
               PRINT 1043,NDIF,IDIFS,ITEMP
 1043          FORMAT(' SFMERG: PASS: average of ',I2,' DIFs is ',I5,
     2              '; < maximum=',I5)
#endif

               IF(NORM_ALT.EQ.1)THEN
                  SAVMERGE=.TRUE.
                  NMERG=NMERG+1
                  I12SAV(1,NMERG)=I12(MAJR)
                  I12SAV(2,NMERG)=I12(MINR)
                  UZSAV(1,NMERG)=USE_Z(MAJR)
                  UZSAV(2,NMERG)=USE_Z(MINR)
                  DIFAMG(NMERG)=IDIFS
                  DIFALT(NMERG)=9999
                  VDIFSV(NMERG)=VELDIF
                  END2S(NMERG)=END2
                  DELMHT(NMERG)=IADV2F+1-IEXT1L
                  NXTMRG(NMERG)=0
                  IF(NMERG.GT.1)NXTMRG(NMERG-1)=NMERG
               ELSE
                  DIFALT(NMERG)=(IDIFS+DIFAMG(NMERG))/2
               ENDIF
            ENDIF
         ENDIF
      ENDIF
      
C EXTRAPOLATE FROM THE OPPOSITE DIRECTION
      IF((SAVMERGE).AND.(NORM_ALT.EQ.1))THEN
         NORM_ALT=2
         GO TO 21
      ENDIF

C BREAK POINT FOR FINISHING TEST OF PAIR-WISE MERGE

 81   CONTINUE

#if defined(CLEO_SFDIAG)
         PRINT 1045
 1045    FORMAT(' SFMERG: waiting for acknowledge....or "K"ill'/
     2          '          or "O"ther to enter selected chains ')

         IF(((I12(1).EQ.SELECTC(1)).AND.(I12(2).EQ.SELECTC(2))).OR.
     2      ((I12(1).EQ.SELECTC(2)).AND.(I12(2).EQ.SELECTC(1))))THEN
            KILLOV=1
            SFMERG_KILLA3=0
         ELSE
            KILLOV=0
         ENDIF

         IF(
     1      ((FIRSTTST.EQ.1).AND.(SFMERG_KILLA3.NE.1)).OR.
     2      (KILLOV.EQ.1).OR.
     3      ((PASS_LEVEL.GE.7).AND.(SFMERG_KILLA3.NE.1))
     4     )THEN
            FIRSTTST=0
            CALL DSF_RFV_INPUT(IGO)
            CALL DSF_ABORT(ABORT)
            IF(ABORT.EQ.1)GO TO 399

            IF(IGO.EQ.'K')THEN
               SFMERG_KILLA3=1

            ELSEIF(IGO.EQ.'O')THEN
               DO 83 ISEL=1,2
                  PRINT 1046,ISEL
 1046             FORMAT(' ENTER CHAIN NUMBER TO DISPLAY', I3)
#if !defined(CLEO_XTSUBS)
                  READ 1047,SELECTC(ISEL)
 1047             FORMAT(I)
#endif
#if defined(CLEO_XTSUBS)
                  CALL XTS_RFV_GETINT
                  SELECTC(ISEL)=XTS_ANSWER_IY
#endif
 83            CONTINUE
            ENDIF

         ENDIF
#endif

      GO TO 7
 89   CONTINUE
91    CONTINUE
      GO TO 3
93    CONTINUE

C ORDER THE MERGES BY PRIORITY
      IF(NMERG.GE.2)THEN
         LAST=0
         DO 97 I=1,NMERG
            NOW=NXTMRG(LAST)
            JMIN=I+1
            NEXT=NOW
            DO 95 J=JMIN,NMERG
               SWAPMERG=0
               LFROM=NEXT
               NEXT=NXTMRG(NEXT)

c23456789 123456789 123456789 123456789 123456789 123456789 123456789 12
C PREFER MERGES WITH VALID MEASUREMENTS FROM BOTH ENDS
C ORDER BY INCREASING MISS DISTANCE
               IF    (DIFALT(NOW).LT.9999)THEN
                  IF    (DIFALT(NEXT).LT.9999)THEN
                     IF(DIFALT(NOW).GT.DIFALT(NEXT))SWAPMERG=1
                  ENDIF
               ELSEIF(DIFALT(NOW).GE.9999)THEN
                  IF    (DIFALT(NEXT).LT.9999)THEN
                     SWAPMERG=1
                  ELSEIF(DIFALT(NEXT).GE.9999)THEN
                     IF(DIFAMG(NOW).GT.DIFAMG(NEXT))SWAPMERG=1
                  ENDIF
               ENDIF

               IF(SWAPMERG.EQ.1)THEN
                  NXTSAV=NXTMRG(NEXT)
                  NXTMRG(LAST)=NEXT
                  NXTMRG(NEXT)=NOW
                  NXTMRG(LFROM)=NXTSAV
                  NOW=NEXT
                  NEXT=LFROM
               ENDIF
 95         CONTINUE
            LAST=NOW
 97      CONTINUE
      ENDIF


#if defined(CLEO_SFDIAG)
      PRINT 1001,NMERG
1001  FORMAT(' SFMERG: FOUND',I4,' POSSIBLE MERGES')
#endif

C END OF SIMPLE MERGE FINDING


C LOOP OVER POSSIBLE MERGES; ARE THE SUBCHAINS STILL AVAILABLE?
      IF(NMERG.LE.0)GO TO 399
      IMERG=0
      DO 395 IDUM=1,NMERG
         IMERG=NXTMRG(IMERG)
         OKMERG=1

#if defined(CLEO_SFDIAG)
         PRINT 1002,IMERG,I12SAV(1,IMERG),I12SAV(2,IMERG),
     2              DIFAMG(IMERG),DIFALT(IMERG),
     3              ICHANU(I12SAV(1,IMERG)),ICHANU(I12SAV(2,IMERG))
 1002    FORMAT(' SFMERG: #',I3,'  CHAINS',I2,' &',I2,
     2          ' DIF=',I5,':',I5,',  ICHANU=',I2,I3)
#endif


C ALLOW A CHAIN TO BE MERGED ON BOTH ENDS
C KEY TO ICHANU....=0  CHAIN IS BAD OR TRIED, DO NOT USE IN ANY WAY
C KEY TO ICHANU....=1  CHAIN IS MARGINAL, CAN BE USED IF PART OF MERGE
C KEY TO ICHANU....=2  CHAIN IS USABLE, BUT CAN NOT BE MERGED AGAIN
C KEY TO ICHANU....=3  CHAIN IS USABLE, CAN BE MERGED TO THE LOW END
C KEY TO ICHANU....=4  CHAIN IS USABLE, CAN BE MERGED TO THE HIGH END
C KEY TO ICHANU....=5  CHAIN IS USABLE AND COMPLETELY MERGEABLE
C I12SAV.....SAVE THE MAJOR AND MINOR CHAIN INDICES
C END1.....THE END(1 OR 2) OF THE MINOR CHAIN THAT POINTS TO MAJOR
C END2.....THE END (1 OR 2) OF THE MAJOR CHAIN THAT POINTS TO MINOR
C SO IF END2S=2, HIGH RADIUS END OF MAJOR POINTS TO MINOR; MAJOR IS LOW RADIUS
C L1.......INDEX OF I12 THAT GIVES THE LOW RADIUS CHAIN
C L2.......INDEX OF I12 THAT GIVES THE HIGH RADIUS CHAIN

         MAJR=1
         MINR=2
         L2=END2S(IMERG)
         L1=3-L2
         CMAJOR=I12SAV(MAJR,IMERG)
         CMINOR=I12SAV(MINR,IMERG)
         CLOWR= I12SAV(L1,IMERG)
         CHIGHR=I12SAV(L2,IMERG)
         DELT=DELMHT(IMERG)
         END2ST=END2S(IMERG)


#if defined(CLEO_SFDIAG)
      PRINT 2011,L1,IMERG,CLOWR,CLOWR,ICHANU(CLOWR)
2011  FORMAT(' SFMERG: INNER CHAIN:  ',
     1       '(I12SAV(L1=',I2,',IMERG=',I3,')=',I4,')'/
     2       '        TEST....ICHANU(I12SAV=',I2,')=',I4,
     3       '; MUST BE 4 OR 5')
      PRINT 2012,L2,IMERG,CHIGHR,CHIGHR,ICHANU(CHIGHR)
2012  FORMAT(' SFMERG: OUTER CHAIN:  ',
     1       '(I12SAV(L2=',I2,',IMERG=',I3,')=',I4,')'/
     2       '        TEST....ICHANU(I12SAV=',I2,')=',I4,
     3       '; MUST BE 3 OR 5')
      PRINT 2013,IMERG,CMINOR,CMINOR,ICHANU(CMINOR),IMERG,DELT
2013  FORMAT(' SFMERG: MINOR CHAIN:  ',
     1       '    (I12SAV(2,IMERG=',I3,')=',I4,')'/
     2       '        (IF DELMHT(',I3,')=',I4,' >0 , THEN......',
     3       '    TEST....ICHANU(I12SAV=',I2,')=',I4,'; MUST BE 5')
#endif


C MUST BE ABLE TO MERGE TO HIGH END OF LOW RADIUS CHAIN
      IF((OKMERG.EQ.1).AND.(ICHANU(CLOWR).NE.5))THEN
         IF(ICHANU(CLOWR).NE.4)OKMERG=0
      ENDIF
C MUST BE ABLE TO MERGE TO LOW END OF HIGH RADIUS CHAIN
      IF((OKMERG.EQ.1).AND.(ICHANU(CHIGHR).NE.5))THEN
         IF(ICHANU(CHIGHR).NE.3)OKMERG=0
      ENDIF
C CAN NOT MERGE IF THE MINOR CHAIN IS GOING TO BE SHORTENED
C AND IF AND IT WAS ALREADY USED (ON THE OTHER END)
      IF((OKMERG.EQ.1).AND.(DELT.GT.0))THEN
         IF(ICHANU(CMINOR).NE.5)OKMERG=0
      ENDIF

#if defined(CLEO_SFDIAG)
      IF(OKMERG.EQ.1)THEN
         PRINT 2014
 2014    FORMAT(' SFMERG: MERGE IS ALLOWED')
      ELSE
         PRINT 2015
 2015    FORMAT(' SFMERG: MERGE IS NOW NOT ALLOWED; CHAINS TAKEN')
      ENDIF

      IN(1)=I12SAV(1,IMERG)
      IN(2)=I12SAV(2,IMERG)
      IN(3)=0
      CALL DSF_CHVIEW(IN)
      PRINT 1003
 1003 FORMAT(' SFMERG: WAITING FOR ACKNOWLEDGE....OR "K"ILL')
      IF(SFMERG_KILLA1.NE.1)THEN
         CALL DSF_RFV_INPUT(IGO)
         CALL DSF_ABORT(ABORT)
         IF(ABORT.EQ.1)GO TO 399
         IF(IGO.EQ.'K')SFMERG_KILLA1=1
      ENDIF
#endif
      IF(OKMERG.NE.1)GO TO 395

      WLOOP=1

C NOW TRY MERGE INTO A NEW CHAIN OR SUPER CHAIN
C COMMON CODE EVEN FOR EXTRA MERGES

201   CONTINUE

C SUPER CHAINS
C CHECK IF THERE IS ENOUGH ROOM FOR A NEW SUPER CHAIN
C AND ADD THE SUPER CHAIN
C SIMPLE CHAINS ARE REFERENCED LIKE SUPER CHAINS TO ALLOW COMPOND MERGE

      IF(CNTLMG.EQ.2)THEN
         IF(NSUPCH+1                           .GT.MSUPCH)GO TO 395
         IF(NSUPCE+SUPCLN(CLOWR)+SUPCLN(CHIGHR).GT.MSUPCE)GO TO 395
         NSUPCH=NSUPCH+1
         SUPCAD(NSUPCH)=NSUPCE+1
         SUPCUS(NSUPCH)=1
         SUPCLN(NSUPCH)=SUPCLN(CLOWR)+SUPCLN(CHIGHR)

#if defined(CLEO_SFDIAG)
      PRINT 2021,NSUPCH,SUPCAD(NSUPCH),SUPCLN(NSUPCH)
 2021 FORMAT(' SFMERG: ADD NEW SUPER CHAIN#',I4,'   ADDRESS',I4,
     1       ' LENGTH=',I2)
#endif


         DO 213 ISUPCE=1,SUPCLN(CLOWR)
            NSUPCE=NSUPCE+1
            SUPCEL(NSUPCE)=SUPCEL(SUPCAD(CLOWR)-1+ISUPCE)

#if defined(CLEO_SFDIAG)
      PRINT 2022,NSUPCE,SUPCEL(NSUPCE)
 2022 FORMAT(' SFMERG: ADD SIMPLE CHAIN(LOWER): ADDRESS',I4,
     1       '       CHAIN',I3)
#endif

 213     CONTINUE
         DO 215 ISUPCE=1,SUPCLN(CHIGHR)
            NSUPCE=NSUPCE+1
            SUPCEL(NSUPCE)=SUPCEL(SUPCAD(CHIGHR)-1+ISUPCE)

#if defined(CLEO_SFDIAG)
      PRINT 2023,NSUPCE,SUPCEL(NSUPCE)
2023  FORMAT(' SFMERG: ADD SIMPLE CHAIN(HIGHR): ADDRESS',I4,
     1       '       CHAIN',I3)
#endif

215   CONTINUE

C MERGED CHAINS
C CHECK IF THERE IS ENOUGH ROOM FOR A NEW MERGED CHAIN
C AND ADD THE CHAIN

      ELSE
         IF(NCHAIN.GE.MCHAIN)GO TO 395
         I3=NCHAIN+1
         I4=0
         DO 231 I=1,MKILCH
            IF(KILCHN(I,CMAJOR).EQ.0)GO TO 232
            IF(I4.GE.MKILCH)GO TO 395
            I4=I4+1
            KILCHN(I4,I3)=KILCHN(I,CMAJOR)
 231     CONTINUE
 232     CONTINUE
         DO 233 I=1,MKILCH
            IF(KILCHN(I,CMINOR).EQ.0)GO TO 234
            IF(I4.GE.MKILCH)GO TO 395
            I4=I4+1
            KILCHN(I4,I3)=KILCHN(I,CMINOR)
 233     CONTINUE
 234     CONTINUE
         I4=I4+1
         IF(I4.GE.MKILCH)GO TO 395
         KILCHN(I4,I3)=I3

C NOW THE MERGE IS CERTAIN
         IF(I4.LT.MKILCH)THEN
            I4=I4+1
            KILCHN(I4,I3)=0
         ENDIF
         NCHAIN=I3

C DO THE MERGE HERE
         LINCHN(NCHAIN)=LINCHN(CLOWR)
         MINCHN(NCHAIN)=MINCHN(CHIGHR)
         LENCHN(NCHAIN)=LENCHN(CLOWR)+LENCHN(CHIGHR)-DELT
         LVLCHN(1,NCHAIN)=LVLCHN(1,CLOWR)
         LVLCHN(2,NCHAIN)=LVLCHN(2,CHIGHR)
         ICHANU(NCHAIN)=2

C ALSO FILL IN THE Z INFO
C LOAD MINOR FIRST SO THAT THE INDEX OF THE ENTRY IS PRESERVED
         ZNCHN(NCHAIN)=0
         SFZMS1(NCHAIN)=0
         SFZMS2(NCHAIN)=0
         ZLOOP=0
 235     ZLOOP=ZLOOP+1
         IF(ZLOOP.EQ.3)GO TO 239         

#if defined(CLEO_SFDIAG)
         PRINT 9994,ZLOOP,UZSAV(2,IMERG),UZSAV(1,IMERG)
 9994    FORMAT(' SFMERG:TESTING Z: LOOP=',I2,' UZ2=',I2,' UZ1=',I2)
#endif

         IF    ((ZLOOP.EQ.1).AND.(UZSAV(2,IMERG).EQ.1))THEN
            ICHAIN=CMINOR
            GO TO 236
         ELSEIF((ZLOOP.EQ.2).AND.(UZSAV(1,IMERG).EQ.1))THEN
            ICHAIN=CMAJOR
            GO TO 236
         ENDIF
         GO TO 235
 236     CONTINUE
         IF(ZNCHN(ICHAIN).GT.0)THEN
            ZNCHN(NCHAIN) =ZNCHN(NCHAIN) +ZNCHN(ICHAIN)
            SFZMS1(NCHAIN)=SFZMS1(NCHAIN)+SFZMS1(ICHAIN)
            SFZMS2(NCHAIN)=SFZMS2(NCHAIN)+SFZMS2(ICHAIN)
            DO 238 ISFZM=1,ZNCHN(ICHAIN)
               SFZMR(ZNCHN(NCHAIN),NCHAIN)=SFZMR(ISFZM,ICHAIN)
               SFZMZ(ZNCHN(NCHAIN),NCHAIN)=SFZMZ(ISFZM,ICHAIN)
               SFZMD(ZNCHN(NCHAIN),NCHAIN)=SFZMD(ISFZM,ICHAIN)
               SFZML(ZNCHN(NCHAIN),NCHAIN)=SFZML(ISFZM,ICHAIN)
 238        CONTINUE
         ENDIF
         GO TO 235

 239     CONTINUE
         IF(ZNCHN(NCHAIN).NE.0)THEN
            ZR0CHN(NCHAIN)=0
            ZDRCHN(NCHAIN)=(SFZMS2(NCHAIN)*MULST)/SFZMS1(NCHAIN)
         ELSE
            ZR0CHN(NCHAIN)=0
            ZDRCHN(NCHAIN)=0
         ENDIF


#if defined(CLEO_SFDIAG)
         PRINT 9993,CMAJOR,CMINOR,NCHAIN,
     2              LINCHN(NCHAIN),MINCHN(NCHAIN),
     3              LENCHN(NCHAIN),DELT,
     4              ZNCHN(NCHAIN),SFZMS1(NCHAIN),SFZMS2(NCHAIN)
 9993    FORMAT(' MERGING chains',I2,' and',I3,' into ',I3/
     2          ' LINCHN=',I5,' MINCHN=',I5,' LEN=',I3,' DELT=',I3/
     3          ' ZNCHN=',I3,' SFZMS1=',I6,' SFZMS2=',I6)

#endif
            
C STEP BACK TO GET END ADDRESS OF MINOR CHAIN
C CHECK IF THE DELETED HIT WAS A SINGLE HIT
C CHECK IF THE DELETED HIT HAS A Z MEASUREMENT; IF SO DELETE IT

         AD2F=LMICHN(CMINOR+(2-END2ST)*MCHAIN)
         ZNDEL=0
         DELTS=0
         IF(DELT.GT.0)THEN
            DO 243 K=1,DELT
               IF(DOUBPT(AD2F).NE.0)DELTS=DELTS+1
               L2F=LAYSSF(SFLSFA(AD2F))
               IF(ZNCHN(CMINOR).GT.0)THEN
                  DO 241 ISFZM=1,ZNCHN(CMINOR)
                     IF(SFZML(ISFZM,CMINOR).EQ.L2F)THEN
                        ZNDEL=ZNDEL+1
                        DIFTN=SFZMD(ISFZM,CMINOR)
                        DIFTNA=DIFTN
                        IF(DIFTN.LT.0)DIFTNA=-DIFTN
                        SUBTR1=DIFTNA
                        SUBTR2=(DIFTNA*
     2                          SFZMZ(ISFZM,CMINOR)*100)
     3                         /SFZMR(ISFZM,CMINOR)
                        SFZMS1(CMINOR)=SFZMS1(CMINOR)-SUBTR1
                        SFZMS2(CMINOR)=SFZMS2(CMINOR)-SUBTR2
                        SFZML(ISFZM,CMINOR)=0

                        SFZMS1(NCHAIN)=SFZMS1(NCHAIN)-SUBTR1
                        SFZMS2(NCHAIN)=SFZMS2(NCHAIN)-SUBTR2
                        SFZML(ISFZM,NCHAIN)=0
            
                     ENDIF
 241              CONTINUE
               ENDIF
               AD2F=ISTFBD(AD2F+(2-END2ST)*MHITSF)
 243        CONTINUE

C CALCULATE THE FINAL COMPRESS THE LISTS Z COORDINATES OF THE MERGED CHAIN
C AND COMPRESS THE LISTS IF THERE WERE DELETIONS
            IF(ZNDEL.GT.0)THEN
               ZNCHNT=ZNCHN(CMINOR)
               ZNCHN(CMINOR)=0
               DO 251 ISFZM=1,ZNCHNT
                  IF(SFZML(ISFZM,CMINOR).NE.0)THEN
                     ZNCHN(CMINOR)=ZNCHN(CMINOR)+1
                     SFZMR(ZNCHN(CMINOR),CMINOR)=SFZMR(ISFZM,CMINOR)
                     SFZMZ(ZNCHN(CMINOR),CMINOR)=SFZMZ(ISFZM,CMINOR)
                     SFZMD(ZNCHN(CMINOR),CMINOR)=SFZMD(ISFZM,CMINOR)
                     SFZML(ZNCHN(CMINOR),CMINOR)=SFZML(ISFZM,CMINOR)
                  ENDIF
 251           CONTINUE

               ZNCHNT=ZNCHN(NCHAIN)
               ZNCHN(NCHAIN)=0
               DO 252 ISFZM=1,ZNCHNT
                  IF(SFZML(ISFZM,NCHAIN).NE.0)THEN
                     ZNCHN(NCHAIN)=ZNCHN(NCHAIN)+1
                     SFZMR(ZNCHN(NCHAIN),NCHAIN)=SFZMR(ISFZM,NCHAIN)
                     SFZMZ(ZNCHN(NCHAIN),NCHAIN)=SFZMZ(ISFZM,NCHAIN)
                     SFZMD(ZNCHN(NCHAIN),NCHAIN)=SFZMD(ISFZM,NCHAIN)
                     SFZML(ZNCHN(NCHAIN),NCHAIN)=SFZML(ISFZM,NCHAIN)
                  ENDIF
 252           CONTINUE


               IF(ZNCHN(CMINOR).NE.0)THEN
                  ZR0CHN(CMINOR)=0
                  ZDRCHN(CMINOR)=(SFZMS2(CMINOR)*MULST)/SFZMS1(CMINOR)
               ELSE
                  ZR0CHN(CMINOR)=0
                  ZDRCHN(CMINOR)=0
               ENDIF
               IF(ZNCHN(NCHAIN).NE.0)THEN
                  ZR0CHN(NCHAIN)=0
                  ZDRCHN(NCHAIN)=(SFZMS2(NCHAIN)*MULST)/SFZMS1(NCHAIN)
               ELSE
                  ZR0CHN(NCHAIN)=0
                  ZDRCHN(NCHAIN)=0
               ENDIF
            ENDIF
            

c23456789 123456789 123456789 123456789 123456789 123456789 123456789 12


C ALSO PERMENENTLY DELETE THE HITS IN THE ORIGINAL CHAIN

            LMICHN(CMINOR+(2-END2ST)*MCHAIN)=AD2F
            LENCHN(CMINOR)=LENCHN(CMINOR)-DELT
            SNGCHN(CMINOR)=SNGCHN(CMINOR)-DELTS

C HAVE NOT KILLED INUCHN AND ISTFOR AND ISTBAK
C GET END ADDRESS OF MAJOR CHAIN

         ENDIF

         SNGCHN(NCHAIN)=SNGCHN(CLOWR)+SNGCHN(CHIGHR)-DELTS

         AD1L=LMICHN(CMAJOR+(END2ST-1)*MCHAIN)
         ISTFBD(AD1L+(2-END2ST)*MHITSF)=AD2F
         ISTFBD(AD2F+(END2ST-1)*MHITSF)=AD1L

         NXTSAV=NXTCHN(CMAJOR)
         NXTCHN(CMAJOR)=I3
         NXTCHN(I3)=NXTSAV

      ENDIF

C THIS IS A DIFFICULT FLOW CHART
C       (CLOWR WILL BE ILLUSTRATED FOR MERGES, NOT SUPER CHAINS)
C                                                       ICHANU(CLOWR)=1
C                                                       ICHANU(CLOWR)=2
C     ICHANU(CLOWR)=3         ICHANU(CLOWR)=5           ICHANU(CLOWR)=4
C
C     O___________X           O___________O             X___________X  1&2
C                                                       X___________O  4
C
C              NEW-MERGE               NEW-MERGE                 NEW-MERGE
C     (NOT ALLOWED)           ( ALLOWED )               ( ONLY "4" ALLOWED)
C          :                      / \                              |
C          :                    /     \                            |
C          :                  /         \                          |
C          :                /             \                        |
C          :              /                 \                      |
C          :       (CLOWR=CMAJOR)      (CLOWR=CMINOR)              |
C          :             |                 /  \                    |
C          :             |               /     \                   |
C          :             |           DEL=0     DEL>0               |
C          :             |          /           |                  |
C          :             |        /             |                  |
C          :             |      /               |                  |
C          :      SET ICHANU(CLOWR)=3           |                  |
C           .          /                        |                  |
C            .        /                         |    SET WASMRG(1,CLOWR)=NCHAIN
C             .      /                          |             /
C              .    /                            \          /
C        SET WASMRG(1,CLOWR)=NCHAIN                \      /
C                                                    \  /
C                                                SET ICHANU(CLOWR)=2


C REMEMBER THAT THIS CHAIN WAS USED IN A MERG
C FOR SUPER CHAINS; ICHANU =5 ALWAYS, IGNORE IT; SAVE ONLY THE FIRST WASMRG
C LOW RADIUS MIGHT STILL BE ABLE TO BE MERGED ON THE LOW END
      IF(CNTLMG.EQ.2)THEN
         IF(WASMRG(1,CLOWR).EQ.0)WASMRG(1,CLOWR)=NSUPCH

      ELSE
         IF(ICHANU(CLOWR).EQ.3)THEN
            WASMRG(1,CLOWR)=NCHAIN
         ELSEIF(ICHANU(CLOWR).EQ.5)THEN
            IF((CLOWR.EQ.CMAJOR).OR.(DELT.LE.0))THEN
               ICHANU(CLOWR)=3
               WASMRG(1,CLOWR)=NCHAIN
            ELSE
               ICHANU(CLOWR)=2
            ENDIF
         ELSE
            WASMRG(1,CLOWR)=NCHAIN
            ICHANU(CLOWR)=2
         ENDIF
      ENDIF

C HIGH RADIUS MIGHT STILL BE ABLE TO BE MERGED ON THE HIGH END
      IF(CNTLMG.EQ.2)THEN
      IF(WASMRG(2,CHIGHR).EQ.0)WASMRG(2,CHIGHR)=NSUPCH

      ELSE
         IF(ICHANU(CHIGHR).EQ.4)THEN
            WASMRG(2,CHIGHR)=NCHAIN
         ELSEIF(ICHANU(CHIGHR).EQ.5)THEN
            IF((CHIGHR.EQ.CMAJOR).OR.(DELT.LE.0))THEN
               ICHANU(CHIGHR)=4
               WASMRG(2,CHIGHR)=NCHAIN
            ELSE
               ICHANU(CHIGHR)=2
            ENDIF
         ELSE
            WASMRG(2,CHIGHR)=NCHAIN
            ICHANU(CHIGHR)=2
         ENDIF
      ENDIF
         

C CHECK IF THERE ARE OTHER IMPLIED MERGES
C CHECK IF THE PRESENT INNER, I12SAV(L1,IMERG), WAS AN OUTER
C IF THE PRESENT OUTER WAS THE MINOR CHAIN AND HAD NOT PREVIOUSLY
C  BEEN USED, IT COULD HAVE BEEN SHORTENED, IT IS ALREADY SHORTENED
C  SO DELT MUST NOW BE =0

#if defined(CLEO_SFDIAG)
      PRINT 2001,WLOOP
2001  FORMAT(' SFMERG: STARTING IMPLIED MERG: WLOOP=',I10)
#endif

      IF(WLOOP.EQ.3)GO TO 395
      IF(WLOOP.EQ.2)GO TO 281

#if defined(CLEO_SFDIAG)
      PRINT 2002,L1,IMERG,I12SAV(L1,IMERG),WASMRG(2,I12SAV(L1,IMERG))
2002  FORMAT(' SFMERG: INNER CHAIN :',
     1       'I12SAV(L1=',I2,',IMERG=',I3,')=',I4/
     2       '         WAS IT AN OUTER?: WASMRG(2,I12SAV)=',I4)
#endif

      IF(WASMRG(2,I12SAV(L1,IMERG)).EQ.0)GO TO 281
      WLOOP=2
      CLOWR=WASMRG(2,I12SAV(L1,IMERG))
      CHIGHR=I12SAV(L2,IMERG)
#if defined(CLEO_SFDIAG)
      PRINT 2003,I12SAV(L1,IMERG),CLOWR,CHIGHR,IMERG,I12SAV(2,IMERG)
2003  FORMAT(' SFMERG: MERGED CHAIN WHEN CH#',I2,' WAS OUTER:',
     1       ' CLOWR=',I3/
     2       '          CURRENT OUTER:  CHIGHR=',I3/
     3      '     =?   CURRENT MINOR CHAIN: I12SAV(2,IMERG=',I3,')=',I4)
#endif
C PRESERVE MAJOR OR MINOR OF PRESENT OUTER
      IF(CHIGHR.EQ.I12SAV(2,IMERG))GO TO 287
      GO TO 285

C CHECK IF THE PRESENT OUTER, I12SAV(L2,IMERG), WAS AN INNER


281   CONTINUE
#if defined(CLEO_SFDIAG)
      PRINT 2004,L2,IMERG,I12SAV(L2,IMERG),WASMRG(1,I12SAV(L2,IMERG))
2004  FORMAT(' SFMERG: OUTER CHAIN :',
     1       'I12SAV(L2=',I2,',IMERG=',I3,')=',I4/
     2       '         WAS IT AN INNER?: WASMRG(1,I12SAV)=',I4)
#endif
      IF(WASMRG(1,I12SAV(L2,IMERG)).EQ.0)GO TO 395
      WLOOP=3
      CHIGHR=WASMRG(1,I12SAV(L2,IMERG))
      CLOWR=I12SAV(L1,IMERG)
#if defined(CLEO_SFDIAG)
      PRINT 2005,I12SAV(L2,IMERG),CHIGHR,CLOWR,IMERG,I12SAV(2,IMERG)
2005  FORMAT(' SFMERG: MERGED CHAIN WHEN CH#',I2,' WAS INNER:',
     1       ' CHIGHR=',I3/
     2       '          CURRENT INNER:  CLOWR=',I3/
     3      '    =?    CURRENT MINOR CHAIN: I12SAV(2,IMERG=',I3,')=',I4)
#endif

C PRESERVE MAJOR OR MINOR OF PRESENT INNER
      IF(CLOWR.EQ.I12SAV(2,IMERG))GO TO 285
      GO TO 287


C THIS PRESERVES END2ST
285   CMAJOR=CHIGHR
      CMINOR=CLOWR
      GO TO 289
287   CMAJOR=CLOWR
      CMINOR=CHIGHR
289   DELT=0

#if defined(CLEO_SFDIAG)
      PRINT 1005,IMERG,CMAJOR,CMINOR,
     1          ICHANU(CMAJOR),ICHANU(CMINOR)
1005  FORMAT(' SFMERG: #',I3,'  CHAINS',I2,' (MAJOR)  &',
     1       I2,' (MINOR) ADDED!!! '
     2        ' ICHANU=',I2,I3)

      IF(CNTLMG.EQ.2)THEN
         IIN=0
         DO 292 ISUPCE=1,SUPCLN(CLOWR)
            IF(IIN.EQ.MCHANM)GO TO 294
            IIN=IIN+1
            IN(IIN)=SUPCEL(SUPCAD(CLOWR)-1+ISUPCE)
 292     CONTINUE
         DO 293 ISUPCE=1,SUPCLN(CHIGHR)
            IF(IIN.EQ.MCHANM)GO TO 294
            IIN=IIN+1
            IN(IIN)=SUPCEL(SUPCAD(CHIGHR)-1+ISUPCE)
 293     CONTINUE
         IF(IIN.EQ.MCHANM)GO TO 294
         IIN=IIN+1
 294     IN(IIN)=0

      ELSE
         IN(1)=CMAJOR
         IN(2)=CMINOR
         IN(3)=0
      ENDIF

      CALL DSF_CHVIEW(IN)
      PRINT 1003
      IF(SFMERG_KILLA2.NE.1)THEN
        CALL DSF_RFV_INPUT(IGO)
        CALL DSF_ABORT(ABORT)
        IF(ABORT.EQ.1)GO TO 399
        IF(IGO.EQ.'K')SFMERG_KILLA2=1
      ENDIF
#endif

      GO TO 201
395   CONTINUE

#if defined(CLEO_SFDIAG)
      IN(1)=0
      CALL DSF_CHVIEW(IN)
#endif

399   CONTINUE

#if defined(CLEO_SFDIAG)
      PRINT 9992,ZDRCHN
 9992 FORMAT(' SFMERGf:ZDRCHN:',10I6)
#endif
      RETURN

C-----------------------------------------------------------------------
C entry to reset conditions
C-----------------------------------------------------------------------
#if defined(CLEO_SFDIAG)
      ENTRY SFMERG0
      RETURN
#endif

      END











